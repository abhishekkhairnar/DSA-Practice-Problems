# Tree Data Structure

# Why we use Trees?

- Efficiently inserting and deleting in O(log n) time complexity.
- Data is ordered in Binary Tree.
- Cost Efficient, restructuring not required.

# Unbalanced Binary tree tree

- every operation is O(n)

# Self balancing binary tree

it is inefficient in sorted data

# use

- file systems
- databases
- network routing
- Algorithms/Networking
- to solve mathematical problems
- huffman coding (file compression)

# Types of Binary Tree

    1) Complete Binary Tree - every node has two nodes from left
    2) Strict Binary Tree - every node is having either 0 or 2 nodes
    3) Perfect Binary Tree - all levels are filled
    4) Height Balanced Binary Tree
    5) Skewed Binary Tree - every node having one child
    6) Ordered Binary Tree - every node having some property

# Properties

    1) Total number of nodes in a perfect binary tree is
            Total nodes = 2^(n+1)-1;
    2) Total number of leaf nodes in a perfect binary tree = 2^height
    3) if we have n number of leaves we have log(n+1) levels at least
    4) strict BT, n leaf nodes we will have n-1 internal nodes
        no of leaf nodes = no of internal nodes + 1
    5) degree of tree
    6) no of leaf nodes = 1 + no of internal nodes with two children

# Implementations

    1) Linked
    2) Sequential

#
